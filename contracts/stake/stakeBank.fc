#pragma version >=0.4.0;

;;  ███████╗ ██████╗ ███╗   ███╗ ██████╗ ██████╗ ██╗   ██╗███████╗██╗  ██╗
;;  ██╔════╝██╔═══██╗████╗ ████║██╔═══██╗██╔══██╗██║   ██║██╔════╝██║  ██║
;;  █████╗  ██║   ██║██╔████╔██║██║   ██║██████╔╝██║   ██║███████╗███████║
;;  ██╔══╝  ██║   ██║██║╚██╔╝██║██║   ██║██╔══██╗██║   ██║╚════██║██╔══██║
;;  ██║     ╚██████╔╝██║ ╚═╝ ██║╚██████╔╝██║  ██║╚██████╔╝███████║██║  ██║
;;  ╚═╝      ╚═════╝ ╚═╝     ╚═╝ ╚═════╝ ╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚═╝  ╚═╝
;;
;;  ███████╗████████╗ █████╗ ██╗  ██╗██╗███╗   ██╗ ██████╗
;;  ██╔════╝╚══██╔══╝██╔══██╗██║ ██╔╝██║████╗  ██║██╔════╝
;;  ███████╗   ██║   ███████║█████╔╝ ██║██╔██╗ ██║██║  ███╗
;;  ╚════██║   ██║   ██╔══██║██╔═██╗ ██║██║╚██╗██║██║   ██║
;;  ███████║   ██║   ██║  ██║██║  ██╗██║██║ ╚████║╚██████╔╝
;;  ╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝ ╚═════╝
;;
;; FomoRush Staking - A decentralized staking platform built on TON blockchain
;; Users can stake their tokens to earn rewards and participate in the ecosystem
;; Staking provides additional benefits and contributes to the FomoRush community
;;
;; Features:
;; • Deny ownership
;; • Flexible staking with 9 days duration (2 days deposit stage, 5 days stake stage, 2 days withdraw stage)
;; • Reward distribution based on staking amount
;; • Integration with FomoRush game ecosystem using dividends
;;
;; Links:
;; • Website: https://fomorush.io
;; • Telegram: @fomorush_bot

#include "imports/stdlib.fc";
#include "utils/op-code.fc";
#include "utils/messages.fc";
#include "utils/jetton-utils.fc";
#include "utils/safemath.fc";

const int factor = 0x3B9ACA00;
const int min_tons_for_storage = 20000000;

const int stage1_duration = 172800; ;; 2 day
const int stage2_duration = stage1_duration + 432000; ;; add 5 days
const int stage3_duration = stage2_duration + 172800; ;; add 2 day

;; storage functions
(int, int, int, int, slice, slice, cell) load_data() inline {
  slice ds = get_data().begin_parse();
  return (
    ds~load_coins(), ;; total_staked
    ds~load_uint(2), ;; stage 0 - init, 1 - deposit stage, 2 - stake stage, 3 - withdraw stage
    ds~load_uint(32), ;; iteration_start_time contain by 3 rounds
    ds~load_coins(), ;; dividends for stage 3
    ds~load_msg_addr(), ;; admin_address
    ds~load_msg_addr(), ;; jetton_master_address
    ds~load_ref() ;; jetton_wallet_code
  );
}

() save_data(
  int total_staked,
  int stage,
  int iteration_start_time,
  int dividends,
  slice admin_address,
  slice jetton_master_address,
  cell jetton_wallet_code
) impure inline {
  set_data(
    begin_cell()
      .store_coins(total_staked)
      .store_uint(stage, 2)
      .store_uint(iteration_start_time, 32)
      .store_coins(dividends)
      .store_slice(admin_address)
      .store_slice(jetton_master_address)
      .store_ref(jetton_wallet_code)
    .end_cell()
  );
}

() save_new_stage(int stage, int iteration_start_time) impure inline {
  (int total_staked, _, _, int dividends, slice admin_address, slice jetton_master_address, cell jetton_wallet_code) = load_data();
  save_data(total_staked, stage, iteration_start_time, dividends, admin_address, jetton_master_address, jetton_wallet_code);
}

(int, int) update_stage(int stage, int iteration_start_time) impure inline {
  throw_if(error::wrong_stage, stage == 0); ;; only allow to update stages when the stage is not 0

  int current_time = now();
  int time_diff = current_time - iteration_start_time;

  ;; stage 1 -> 2
  if (stage == 1 & (time_diff >= stage1_duration)) {
    stage = 2;
  }

  ;; stage 2 -> 3
  if (stage == 2 & (time_diff >= stage2_duration)) {
    stage = 3;
  }

  ;; stage 3 -> 1
  if (stage == 3 & (time_diff >= stage3_duration)) {
    stage = 1;
    iteration_start_time = iteration_start_time + stage3_duration;
  }

  return (stage, iteration_start_time);
}

;; recv_internal is the main function of the contract and is called when it receives a message from other contracts
() recv_internal(int balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
  if (in_msg_body.slice_empty?()) { ;; ignore all empty messages
    return ();
  }

  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);

  if (flags & 1) { ;; ignore all bounced messages
    return ();
  }

  slice sender_address = cs~load_msg_addr();
  int op = in_msg_body~load_op();

  (
    int total_staked, int stage, int iteration_start_time, int dividends,
    slice admin_address, slice jetton_master_address, cell jetton_wallet_code
  ) = load_data();

  ;; ------- handle dividends operations -------
  if (op == op::dividends_transfer) {
    int current_stage = stage;
    (int stage, int iteration_start_time) = update_stage(stage, iteration_start_time);

    if (stage != 3) {
      dividends += msg_value;
    }

    if(current_stage != stage) {
      save_new_stage(stage, iteration_start_time);

      if ((current_stage == 3) & (stage == 1)) {
        dividends = balance - min_tons_for_storage;
      }
    }

    save_data(
      total_staked, stage, iteration_start_time, dividends, 
      admin_address, jetton_master_address, jetton_wallet_code
    );

    return ();
  }

  ;; -------- Deny ownership --------
  if (op == op::deny_ownership) {
    throw_unless(error::unauthorized_change_content_request, equal_slices_bits(sender_address, admin_address));
    slice self_owner = my_address(); ;; set the admin address to the current contract address
    save_data(
      total_staked, stage, iteration_start_time, dividends, self_owner, jetton_master_address, jetton_wallet_code
    );
    return ();
  }

  ;; ------- handle bank operations -------
  if (op == op::change_jetton_master) {
    throw_unless(error::unauthorized_change_content_request, equal_slices_bits(sender_address, admin_address));
    save_data(
      total_staked, stage, iteration_start_time, dividends, 
      admin_address, in_msg_body~load_msg_addr(), jetton_wallet_code
    );

    return ();
  }

  ;; initiate the staking - set current stage to 1 and start time to the current block time
  if (op == op::init_staking) {
    throw_unless(error::wrong_stage, stage == 0); ;; only allow to init staking when the stage is 0
    throw_unless(error::unauthorized_change_content_request, equal_slices_bits(sender_address, admin_address));
    save_data(total_staked, 1, now(), dividends, admin_address, jetton_master_address, jetton_wallet_code);

    return ();
  }

  int amount = in_msg_body~load_coins(); ;; load the amount of tokens
  slice from_address = in_msg_body~load_msg_addr();
  ;; save the current stage to check if it has changed
  int current_stage = stage;

  ;; check and update the stage if needed
  (int stage, int iteration_start_time) = update_stage(stage, iteration_start_time);

  ;; ------- handle stake operations -------
  ;; deposit stake
  if (op == op::deposit_stake) {
    throw_unless(error::invalid_amount, amount > 0);
    ;; only allow deposits from the user's jetton wallet
    throw_unless(error::unauthorized_incoming_transfer,
      equal_slices_bits(calc_user_wallet(from_address, jetton_master_address, jetton_wallet_code), sender_address)
    );

    raw_reserve(min_tons_for_storage, 2);

    ;; only allow deposits in stage 1 aka stake stage
    if ((current_stage == 1) & (stage != current_stage)) {
      ;; revert the transaction
      var msg_body = begin_cell()
                  .store_op(op::deposit_stake_wrong_stage)
                  .store_coins(amount)
                  .store_slice(sender_address)
                  .end_cell();

      var msg = begin_cell()
                .store_msg_flag(msg_flag::non_bounceable)
                .store_slice(sender_address)
                .store_coins(0)
                .store_msgbody_prefix_ref(msg_body);

      save_new_stage(stage, iteration_start_time);
      send_raw_message(msg.end_cell(), CARRY_REMAINING_GAS);  

      return();
    }
    
    throw_unless(error::wrong_stage, stage == 1);

    ;; return the remaining gas to the user
    if ((from_address.preload_uint(2) != 0)) {
      var msg = begin_cell()
        .store_uint(msg_flag::non_bounceable, 6)
        .store_slice(from_address)
        .store_coins(0)
        .store_msgbody_prefix_slice();

      send_raw_message(msg.end_cell(), CARRY_REMAINING_GAS);
    }

    save_data(
      total_staked + amount, stage, iteration_start_time, dividends, 
      admin_address, jetton_master_address, jetton_wallet_code
    );

    return ();
  }

  ;; withdraw stake
  if (op == op::withdraw_stake) {
    throw_unless(error::invalid_amount, amount > 0 & (amount <= total_staked));
    throw_unless(error::empty_stake_bank, total_staked > 0);
    ;; only allow withdrawals from the user's jetton wallet
    throw_unless(error::unauthorized_incoming_transfer,
      equal_slices_bits(calc_user_wallet(from_address, jetton_master_address, jetton_wallet_code), sender_address)
    );    

    ;; reserve the storage for the user
    raw_reserve(min_tons_for_storage, 2);

    ;; if stage has changed from 3 to 1, revert the transaction
    if ((stage == 1) & (stage != current_stage)) {
      var msg_body = begin_cell()
                  .store_op(op::withdraw_stake_wrong_stage)
                  .store_coins(amount)
                  .store_slice(sender_address)
                  .end_cell();

      var msg = begin_cell()
                .store_msg_flag(msg_flag::non_bounceable)
                .store_slice(sender_address)
                .store_coins(0)
                .store_msgbody_prefix_ref(msg_body);

      send_raw_message(msg.end_cell(), CARRY_REMAINING_GAS);
      save_new_stage(stage, iteration_start_time);

      return();
    }

    ;; if the stage has changed from 2 to 3, save the new stage
    if ((stage == 3) & (stage != current_stage)) {
      save_new_stage(stage, iteration_start_time);
    }

    throw_unless(error::wrong_stage, stage == 3);

    ;; calculate the user share and ton revenue
    int user_share = muldiv(amount, factor, total_staked);
    int tonRevenue = muldiv(dividends, user_share, factor);

    ;; Add bounds checking for overflow protection
    throw_unless(error::overflow_protection, user_share <= factor);
    throw_unless(error::overflow_protection, tonRevenue <= dividends);
    

    ;; validate the dividends
    throw_unless(error::insufficient_dividends, dividends >= tonRevenue);

    var msg_body = begin_cell()
                  .store_op(op::withdraw_stake_notification)
                  .store_coins(amount)
                  .store_slice(from_address)
                  .end_cell();

    var msg = begin_cell()
              .store_msg_flag(msg_flag::non_bounceable)
              .store_slice(sender_address)
              .store_coins(tonRevenue + min_tons_for_storage / 10)
              .store_msgbody_prefix_ref(msg_body);

    send_raw_message(msg.end_cell(), CARRY_REMAINING_GAS);

    save_data(
      total_staked - amount, stage, iteration_start_time, dividends - tonRevenue, 
      admin_address, jetton_master_address, jetton_wallet_code
    );

    return ();
  }

  throw(error::unknown_op); ;; if the message contains an op that is not known to this contract, we throw
}

(int, int, int, int, slice, slice, cell) get_stake_data() method_id {
  return load_data();
}