#pragma version >=0.4.0;

;;  ███████╗ ██████╗ ███╗   ███╗ ██████╗ ██████╗ ██╗   ██╗███████╗██╗  ██╗
;;  ██╔════╝██╔═══██╗████╗ ████║██╔═══██╗██╔══██╗██║   ██║██╔════╝██║  ██║
;;  █████╗  ██║   ██║██╔████╔██║██║   ██║██████╔╝██║   ██║███████╗███████║
;;  ██╔══╝  ██║   ██║██║╚██╔╝██║██║   ██║██╔══██╗██║   ██║╚════██║██╔══██║
;;  ██║     ╚██████╔╝██║ ╚═╝ ██║╚██████╔╝██║  ██║╚██████╔╝███████║██║  ██║
;;  ╚═╝      ╚═════╝ ╚═╝     ╚═╝ ╚═════╝ ╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚═╝  ╚═╝
;;
;;  ███████╗██████╗ ███████╗██╗  ██╗
;;  ██╔════╝██╔══██╗██╔════╝██║  ██║
;;  █████╗  ██████╔╝███████╗███████║
;;  ██╔══╝  ██╔══██╗╚════██║██╔══██║
;;  ██║     ██║  ██║███████║██║  ██║
;;  ╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝
;;
;; FomoRush FRSH Main Jettons - The native token of the FomoRush ecosystem
;; FRSH tokens power the game economy
;; Token holders can participate in staking, earn rewards, and shape the future
;;
;; Features:
;; • 5 stages ICO distribution with fair launch mechanics
;; • Token supply limited to 50 billion tokens
;; • No pre-sale and private rounds
;; • No mint
;; • Integration with FomoRush game and staking platforms
;;
;; Links:
;; • Website: https://fomorush.io
;; • Telegram: @fomorush_bot
;;

#include "./imports/stdlib.fc";
#include "jetton-utils.fc";
#include "error-codes.fc";
#include "op-codes.fc";
#include "params.fc";
#include "messages.fc";

;; Jettons discoverable smart contract

;; 6905(computational_gas_price) * 1000(cur_gas_price) = 6905000
;; ceil(6905000) = 10000000 ~= 0.01 TON
const int provide_address_gas_consumption = 10000000;
const int hard_cap = 50000000000 {- 50 billion -}; ;; hard cap for ICO in jettons

;; ICO amount validation constants - Case 2A
const int MIN_BUY_AMOUNT = 500000000; ;; 0.5 TON minimum
const int MAX_BUY_AMOUNT = 1000000000000; ;; 1000 TON maximum

;; ICO stage duration validation constants - Case 2E
const int MAX_ICO_STAGE_DURATION = 28 * 24 * 60 * 60; ;; 4 weeks maximum
const int MIN_ICO_STAGE_DURATION = 24 * 60 * 60; ;; 1 day minimum

;; storage scheme
;; storage#_ total_supply:Coins pause:uint1 price:uint64 cap:uint64 start_date:uint32 end_date:uint32 admin_address:MsgAddress content:^Cell jetton_wallet_code:^Cell = Storage;

(int, int, int, int, int, int, slice, slice, cell, cell) load_data() inline {
  slice ds = get_data().begin_parse();
  return (
    ds~load_coins(), ;; total_supply
    ds~load_uint(1), ;; pause
    ds~load_uint(64), ;; price
    ds~load_uint(64), ;; cap
    ds~load_uint(32), ;; start_date
    ds~load_uint(32), ;; end_date
    ds~load_msg_addr(), ;; stake_address
    ds~load_msg_addr(), ;; admin_address
    ds~load_ref(), ;; content
    ds~load_ref() ;; jetton_wallet_code
  );
}

() save_data(
  int total_supply, int pause, int price, int cap, int start_date, int end_date,
  slice stake_address, slice admin_address, cell content, cell jetton_wallet_code
) impure inline {
  set_data(begin_cell()
            .store_coins(total_supply)
            .store_uint(pause, 1)
            .store_uint(price, 64)
            .store_uint(cap, 64)
            .store_uint(start_date, 32)
            .store_uint(end_date, 32)
            .store_slice(stake_address)
            .store_slice(admin_address)
            .store_ref(content)
            .store_ref(jetton_wallet_code)
            .end_cell()
  );
}

int division(int a, int b) asm "x{A904} s,";   ;; 65 gas units

() mint_tokens(slice to_address, cell jetton_wallet_code, int amount, cell master_msg) impure {
  cell state_init = calculate_jetton_wallet_state_init(to_address, my_address(), jetton_wallet_code);
  slice to_wallet_address = calc_address(state_init);
  var msg = begin_cell()
            .store_msg_flag(msg_flag::bounceable)
            .store_slice(to_wallet_address)
            .store_coins(amount)
            .store_msgbody_prefix_stateinit(state_init, master_msg);
  send_raw_message(msg.end_cell(), PAY_FEES_SEPARATELY); ;; pay transfer fees separately, revert on errors
}

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
  slice cs = in_msg_full.begin_parse();
  int flags = cs~load_uint(4);
  if (flags & 1) { ;; ignore all bounced messages
    return ();
  }
  if (in_msg_body.slice_empty?()) { ;; ignore empty messages
    return ();
  }
  slice sender_address = cs~load_msg_addr();
  cs~load_msg_addr(); ;; skip dst
  cs~load_coins(); ;; skip value
  cs~skip_bits(1); ;; skip extracurrency collection
  cs~load_coins(); ;; skip ihr_fee
  int fwd_fee = muldiv(cs~load_coins(), 3, 2); ;; we use message fwd_fee for estimation of forward_payload costs

  (int total_supply, int pause, int price, int cap, int start_date, int end_date,
    slice stake_address, slice admin_address, cell content, cell jetton_wallet_code) = load_data();

  int op = in_msg_body~load_op();
  int query_id = in_msg_body~load_query_id();

  ;; excesses#553276db query_id:uint64 = InternalMsgBody;
  if (op == op::excesses) { ;; just got excessed TON by operation
    return ();
  }

  ;; buy#402eff0b query_id:uint64 = InternalMsgBody;
  if (op == op::buy) { ;; buy jettons for TON
    throw_unless(error::ico_closed, (start_date == 0) | (start_date < now()));
    throw_unless(error::ico_expired, (end_date == 0) | (end_date > now()));
    throw_unless(error::paused, pause == 0);

    int buy_amount = msg_value - min_tons_for_storage;
    throw_unless(error::min_amount, buy_amount >= MIN_BUY_AMOUNT);
    throw_unless(error::max_amount_exceeded, buy_amount <= MAX_BUY_AMOUNT);
    throw_unless(error::overflow_protection, msg_value >= min_tons_for_storage);

    int jetton_amount = muldiv(1, buy_amount, price);

    throw_unless(error::cap_exceeded, total_supply + jetton_amount < cap);

    var mint_request = begin_cell()
                        .store_op(op::internal_transfer)
                        .store_query_id(0)
                        .store_coins(jetton_amount) ;; max 124 bit
                        .store_uint(0, 2) ;; from_address, addr_none$00
                        .store_slice(my_address()) ;; response_address, 3 + 8 + 256 = 267 bit
                        .store_coins(0) ;; forward_amount, 4 bit if zero
                        .store_uint(0, 1) ;; no forward_payload, 1 bit
                        .store_slice(stake_address) ;; address of stake contract
                        .end_cell();

    mint_tokens(sender_address, jetton_wallet_code, min_tons_for_storage, mint_request);
    save_data(
      total_supply + jetton_amount, pause, price, cap, start_date, end_date,
      stake_address, admin_address, content, jetton_wallet_code
    );
    return ();
  }

  {-
    burn_notification#7bdd97de query_id:uint64 amount:(VarUInteger 16)
                 sender:MsgAddress response_destination:MsgAddress
                 = InternalMsgBody;
  -}
  if (op == op::burn_notification) {
    int jetton_amount = in_msg_body~load_coins();
    slice from_address = in_msg_body~load_msg_addr();

    throw_unless(
      error::unauthorized_burn_request,
      equal_slices_bits(calc_user_wallet(from_address, my_address(), jetton_wallet_code), sender_address)
    );
    save_data(
      total_supply - jetton_amount, pause, price, cap, start_date, end_date,
      stake_address, admin_address, content, jetton_wallet_code
    );

    slice response_address = in_msg_body~load_msg_addr();
    if (response_address.preload_uint(2) != 0) {
      var msg = begin_cell()
                .store_msg_flag(msg_flag::non_bounceable)
                .store_slice(response_address)
                .store_coins(0)
                .store_msgbody_prefix_slice()
                .store_op(op::excesses)
                .store_query_id(query_id);
      send_raw_message(msg.end_cell(), IGNORE_ERRORS | CARRY_REMAINING_GAS);
    }

    return ();
  }

  ;; provide_wallet_address#2c76b973 query_id:uint64 owner_address:MsgAddress include_address:Bool = InternalMsgBody;
  if (op == op::provide_wallet_address) {
    throw_unless(error::discovery_fee_not_matched, msg_value > fwd_fee + provide_address_gas_consumption);

    slice owner_address = in_msg_body~load_msg_addr();
    int include_address? = in_msg_body~load_uint(1);

    cell included_address = include_address? ? begin_cell().store_slice(owner_address).end_cell() : null();

    var msg = begin_cell()
                .store_msg_flag(msg_flag::bounceable)
                .store_slice(sender_address)
                .store_coins(0)
                .store_msgbody_prefix_slice()
                .store_op(op::take_wallet_address)
                .store_query_id(query_id);

    if (is_resolvable?(owner_address)) {
      msg = msg.store_slice(calc_user_wallet(owner_address, my_address(), jetton_wallet_code));
    } else {
      msg = msg.store_uint(0, 2); ;; addr_none
    }
    send_raw_message(msg.store_maybe_ref(included_address).end_cell(), CARRY_REMAINING_GAS);
    return ();
  }

  ;; change_admin#4840664f query_id:uint64 new_admin_address:MsgAddress = InternalMsgBody;
  if (op == op::change_admin) {
    throw_unless(error::unauthorized_change_admin_request, equal_slices_bits(sender_address, admin_address));
    slice new_admin_address = in_msg_body~load_msg_addr();
    save_data(
      total_supply, pause, price, cap, start_date, end_date,
      stake_address, new_admin_address, content, jetton_wallet_code
    );
    return ();
  }

  ;; change_content#11067aba query_id:uint64 new_content:Cell = InternalMsgBody;
  if (op == op::change_content) {
    throw_unless(error::unauthorized_change_content_request, equal_slices_bits(sender_address, admin_address));
    save_data(
      total_supply, pause, price, cap, start_date, end_date,
      stake_address, admin_address, in_msg_body~load_ref(), jetton_wallet_code
    );
    return ();
  }

  ;; change_state#58ca5361 query_id:uint64 pause:uint1 = InternalMsgBody;
  if (op == op::change_state) {
    throw_unless(error::unauthorized_change_content_request, equal_slices_bits(sender_address, admin_address));
    save_data(
      total_supply, in_msg_body~load_uint(1), price, cap, start_date, end_date,
      stake_address, admin_address, content, jetton_wallet_code
    );
    return ();
  }

  ;; change_sales_round#4840664f query_id:uint64 new_price:uint64 new_cap:uint64 new_start_date:uint32 new_end_date:uint32 = InternalMsgBody;
  if (op == op::change_sales_round) {
    throw_unless(error::unauthorized_change_content_request, equal_slices_bits(sender_address, admin_address));

    int newPrice = in_msg_body~load_uint(64);
    int newCap = in_msg_body~load_uint(64);
    int newStartDate = in_msg_body~load_uint(32);
    int newEndDate = in_msg_body~load_uint(32);

    throw_unless(error::price, newPrice >= price);

    ;; Add date validation - Case 2E
    if ((newStartDate != 0) & (newEndDate != 0)) {
      throw_unless(error::dates, (newStartDate > now()) & (newStartDate > end_date) & (newEndDate > newStartDate));
      throw_unless(error::ico_duration_too_long, (newEndDate - newStartDate) <= MAX_ICO_STAGE_DURATION);
      throw_unless(error::ico_duration_too_short, (newEndDate - newStartDate) >= MIN_ICO_STAGE_DURATION);
    }

    if (newCap > hard_cap) {
      newCap = hard_cap;
    }

    save_data(
      total_supply, pause,
      newPrice,
      newCap,
      newStartDate,
      newEndDate,
      stake_address, admin_address, content, jetton_wallet_code
    );
    return ();
  }

  ;; withdraw#46ed2e94 query_id:uint64 = InternalMsgBody;
  if (op == op::withdraw) {
    throw_unless(error::unauthorized_withdraw_request, equal_slices_bits(sender_address, admin_address));
    raw_reserve(min_tons_for_storage , 0);
    cell message_body = begin_cell() ;; Creating a cell with message
                        .store_uint(0, 32)
                        .store_slice("withdrawal")
                        .end_cell();
    var msg = begin_cell()
                .store_msg_flag(msg_flag::non_bounceable)
                .store_slice(admin_address)
                .store_coins(0)
                .store_msgbody_prefix_ref(message_body);
    return send_raw_message(msg.end_cell(), CARRY_REMAINING_BALANCE | IGNORE_ERRORS);
  }

  throw(error::unknown_op);
}

(int, int, int, int, int) get_ico_data() method_id {
  (
    int total_supply, int pause, int price, int cap, int start_date, int end_date,
    slice stake_address, slice admin_address, cell content, cell jetton_wallet_code
  ) = load_data();

  return (pause, price, cap, start_date, end_date);
}

int get_jetton_amount(int ton_amount) method_id {
  (
    int total_supply, int pause, int price, int cap, int start_date, int end_date,
    slice stake_address, slice admin_address, cell content, cell jetton_wallet_code
  ) = load_data();

  int buy_amount = ton_amount - min_tons_for_storage;
  throw_unless(error::min_amount, buy_amount > 0);

  return division(buy_amount, price);
}

(int, int, slice, cell, cell) get_jetton_data() method_id {
  (
    int total_supply, int pause, int price, int cap, int start_date, int end_date,
    slice stake_address, slice admin_address, cell content, cell jetton_wallet_code
  ) = load_data();

  return (total_supply, -1, admin_address, content, jetton_wallet_code);
}

slice get_wallet_address(slice owner_address) method_id {
  (
    int total_supply, int pause, int price, int cap, int start_date, int end_date,
    slice stake_address, slice admin_address, cell content, cell jetton_wallet_code
  ) = load_data();

  return calc_user_wallet(owner_address, my_address(), jetton_wallet_code);
}